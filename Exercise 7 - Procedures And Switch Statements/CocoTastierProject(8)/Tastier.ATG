COMPILER Tastier
   const int // object kinds
      var = 0, proc = 1, constant = 3;

   const int // types
      undef = 0, integer = 1, boolean = 2;

   const int // var sub-categories
      scalar = 0, array = 1;

   public SymbolTable tab;
   public CodeGenerator gen;

   public void padStack(int numParameters){
      int bytePadding = numParameters * 4;
      Console.WriteLine("    ADD     TOP, TOP, #{0}      ; create space for parameters", bytePadding);
   }

   public void addParamToStack(int paramNum){
      int offset = -(paramNum * 4);
      Console.WriteLine("    STR     R1, [TOP, #{0}]      ; add to stack", offset);
   }

/*-------------------------------------------------------------------------------------------*/

CHARACTERS

  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.
  digit = "0123456789".
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  stringCh = ANY - '"' - '\\' - cr - lf - tab.
  printableCh = '\u0020' .. '\u007e'.

/*-------------------------------------------------------------------------------------------*/

TOKENS

  number = digit { digit }.
  ident = letter { letter | digit }.
  string = '"' {stringCh | '\\' printableCh} '"'.

/*-------------------------------------------------------------------------------------------*/

COMMENTS FROM "//" TO lf
COMMENTS FROM "/*" TO "*/" NESTED

/*-------------------------------------------------------------------------------------------*/

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------------------------*/

PRODUCTIONS

AddOp<out Op op>
=                        (. op = Op.ADD; .)
  ( '+'
  | '-'                  (. op = Op.SUB; .)
  )
.

/*-------------------------------------------------------------------------------------------*/

Expr<out int reg,        // load value of Expr into register
     out int type>       (. int typeR, regR; Op op; .)
  = SimExpr<out reg,
            out type>
  [ RelOp<out op>
    SimExpr<out regR,
            out typeR>   (.
                            if (type == typeR) {
                               type = boolean;
                               gen.RelOp(op, reg, regR);
                            }
                            else SemErr("incompatible types");
                         .)
   ]                     (. gen.ClearRegisters(); .)
.

/*-------------------------------------------------------------------------------------------*/

Primary<out int reg,     // load Primary into register
        out int type>    (. int n; Obj obj; string name; .)
=                        (.
                            type = undef;
                            reg = gen.GetRegister();
                            int index = 0;
                         .)
  ( Ident<out name>      (. obj = tab.Find(name); type = obj.type; .)
  [
    "["
        number          (.
                          index = Convert.ToInt32(t.val);

                          if(index > obj.lastIndex | index < 0)
                            SemErr("Error: array index out of bounds");
                        .)
    "]"
  ]
                          (.

                            if (obj.kind == var) {
                               if (obj.level == 0)
                                  gen.LoadGlobal(reg, obj.adr + index, name);
                               else
                                  gen.LoadLocal(reg, tab.curLevel-obj.level, obj.adr + index, name);
                               if (type == boolean)
                               // reset Z flag in CPSR
                                  gen.ResetZ(reg);
                            }
                            else SemErr("variable or constant expected");
                         .)

  | number               (.
                            type = integer;
                            n = Convert.ToInt32(t.val);
                            gen.LoadConstant(reg, n);
                         .)

  | '-'
    Primary<out reg,
            out type>     (.
                            if (type == integer)
                               gen.NegateValue(reg);
                            else SemErr("integer type expected");
                         .)

  | "true"               (.
                               type = boolean;
                               gen.LoadTrue(reg);
                         .)

  | "false"              (.
                               type = boolean;
                               gen.LoadFalse(reg);
                         .)

  | '('
    Expr<out reg,
         out type>
    ')'

  )
.

/*-------------------------------------------------------------------------------------------*/

Ident<out string name>
= ident                  (. name = t.val; .)
.

/*-------------------------------------------------------------------------------------------*/

String<out string text>
= string                  (. text = t.val; .)
.

/*-------------------------------------------------------------------------------------------*/

MulOp<out Op op>
=                        (. op = Op.MUL; .)
  ( '*'
  | ("div" | "DIV")      (. op = Op.DIV; .)
  | ("mod" | "MOD")      (. op = Op.MOD; .)
  )
.

/*-------------------------------------------------------------------------------------------*/

ProcDecl<string progName>
                         (. Obj obj; string procName; .)
= "void"
  Ident<out procName>    (.
                            obj = tab.NewObj(procName, proc, undef, undef, -1, 0, 0);
                            if (procName == "main")
                               if (tab.curLevel == 0)
                                  tab.mainPresent = true;
                               else SemErr("main not at lexic level 0");
                            tab.OpenScope();
                         .)
  '('                    (. int paramCount = 0; .)
  /* TODO: Don't forget to handle arrays */
  [
    ParamDecl<out paramCount>
  ]
  ')'                    (. obj.numParameters = paramCount; .)
  '{'
     {
     ConstantDecl
     }
     {
     VarDecl
     }
     {
     ProcDecl<progName>
     }                   (.
                            if (procName == "main")
                               gen.Label("Main", "Body");
                            else {
                               gen.ProcNameComment(procName);
                               gen.Label(procName, "Body");
                            }
                         .)
     Stat { Stat }
  '}'                    (.
                            if (procName == "main") {
                               gen.StopProgram(progName);
                               gen.Enter("Main", tab.curLevel, tab.topScope.nextAdr);
                            } else {
                               gen.Return(procName);
                               gen.Enter(procName, tab.curLevel, tab.topScope.nextAdr);
                            }
                            tab.CloseScope();
                         .)
.

/*-------------------------------------------------------------------------------------------*/

RelOp<out Op op>
=                        (. op = Op.EQU; .)
  ( "="
  | '<'                  (. op = Op.LSS; .)
  | '>'                  (. op = Op.GTR; .)
  | "!="                 (. op = Op.NEQ; .)
  | "<="                 (. op = Op.LEQ; .)
  | ">="                 (. op = Op.GEQ; .)
  )
.

/*-------------------------------------------------------------------------------------------*/

SimExpr<out int reg,     //load value of SimExpr into register
        out int type>    (. int typeR, regR; Op op; .)
= Term<out reg,
       out type>
  { AddOp<out op>
    Term<out regR,
         out typeR>      (.
                            if (type == integer && typeR == integer)
                               gen.AddOp(op, reg, regR);
                            else SemErr("integer type expected");
                         .)
  }
.

/*-------------------------------------------------------------------------------------------*/

Stat                     (. int type; string name; Obj obj; int reg = 0; int index = 0; string arrayName;  .)
= Ident<out name>        (. obj = tab.Find(name); .)
  [
    "["
        number          (.
                          index = Convert.ToInt32(t.val);
                          if(index > obj.lastIndex | index < 0)
                            SemErr("Error: array index out of bounds");
                        .)
    "]"
  ]
  ( ":="
                            (.
                            if ( obj.kind == proc || (obj.kind == constant && obj.initialised) )
                               if(obj.kind != constant)
                                SemErr("cannot assign to procedure");
                               else
                                SemErr("cannot assign to an initialised constant");
                            .)

        ( Expr<out reg,
             out type>       (.
                               if (type == obj.type)
                                  if (obj.level == 0)
                                     gen.StoreGlobal(reg, obj.adr + index, name);
                                  else gen.StoreLocal(reg, tab.curLevel-obj.level, obj.adr + index, name);
                                  obj.initialised = true;
                             .)

        | "["                (. int arrayIndex = 0; .)
          number             (. index = Convert.ToInt32(t.val); .)
          "]"
          Ident<out arrayName> (.
                              Obj arrayObj = tab.Find(arrayName);

                              if(arrayIndex > arrayObj.lastIndex | arrayIndex < 0)
                                SemErr("Error: array index out of bounds");

                              if(arrayObj.type != obj.type){
                                SemErr("Error: incompatible types within assignment");
                              }

                              if (arrayObj.kind == var || arrayObj.kind == constant) {
                                 if (arrayObj.level == 0)
                                    gen.LoadGlobal(reg, arrayObj.adr + arrayIndex, arrayName);
                                 else
                                    gen.LoadLocal(reg, tab.curLevel-obj.level, arrayObj.adr + arrayIndex, arrayName);
                                 if (obj.type == boolean)
                                 // reset Z flag in CPSR
                                    gen.ResetZ(reg);

                                 if (obj.level == 0)
                                   gen.StoreGlobal(reg, obj.adr + index, name);
                                 else gen.StoreLocal(reg, tab.curLevel-obj.level, obj.adr + index, name);
                                   obj.initialised = true;
                              }
                           .)
        | '<' Expr<out reg,
            out type> '>' '?' (.
                                int reg2, type2, reg3, type3;
                                int l1 = 0; int l2 = 1;
                                if (type == boolean) {
                                   l1 = gen.NewLabel();
                                   gen.BranchFalse(l1);
                                }
                                else SemErr("boolean type expected");
                              .)
          Expr<out reg2,
            out type2> ':'  (.
                              l2 = gen.NewLabel();
                              gen.Branch(l2);
                              gen.Label(l1);
                              if (obj.level == 0)
                                 gen.StoreGlobal(reg2, obj.adr + index, name);
                              else
                                 gen.StoreLocal(reg2, tab.curLevel-obj.level, obj.adr + index, name);
                            .)

          Expr<out reg3,
              out type3>
                            (. gen.Label(l2);
                                if (obj.level == 0)
                                   gen.StoreGlobal(reg3, obj.adr + index, name);
                                else
                                   gen.StoreLocal(reg3, tab.curLevel-obj.level, obj.adr + index, name);
                            .)
        )';'


  |'('                      (.
                              string paramName; Obj param; int numParams = 0;

                            .)
    [
      Ident<out paramName>  (.
                              padStack(obj.numParameters);
                              if (obj.kind != proc)
                                 SemErr("object is not a procedure");

                              param = tab.Find(paramName);
                              numParams += 1;
                              gen.LoadLocalAddress(tab.curLevel-param.level, param.adr);
                              addParamToStack(numParams);
                            .)
      {
        "," Ident<out paramName>  (.
                                param = tab.Find(paramName);
                                numParams += 1;
                                gen.LoadLocalAddress(tab.curLevel-param.level, param.adr);
                                addParamToStack(numParams);
                              .)
      }
    ]                         (.
                                if(numParams != obj.numParameters)
                                  SemErr("Error: incorrect number of parameters");

                                // #1: add buffer to stack
                                // #2: push addresses (loadLocalAddress) to stack space

                              .)
    ')' ';'                   (.
                                  if (obj.kind == proc)
                                    gen.Call(name);
                                  else SemErr("object is not a procedure");
                              .)
  )

| "if"                   (. int l1, l2; l1 = 0; .)
  Expr<out reg,
       out type>         (.
                            if (type == boolean) {
                               l1 = gen.NewLabel();
                               gen.BranchFalse(l1);
                            }
                            else SemErr("boolean type expected");
                         .)
      Stat               (.
                            l2 = gen.NewLabel();
                            gen.Branch(l2);
                            gen.Label(l1);
                         .)
      [ "else"
      Stat
      ]               	 (. gen.Label(l2); .)

| "switch"               (. int breakLabel = 0, switchReg; breakLabel = gen.NewLabel(); .)
  Expr<out switchReg, out type>
  "{"
      {                  (.gen.GetRegister();.)
        "case"
        Expr<out reg,
        out type>  ":"     (. int l1, l2; l1 = 0;      //stuff for recognizing cases
                              l1 = gen.NewLabel();
                              gen.RelOp(Op.EQU, reg, switchReg);
                              gen.BranchFalse(l1);
                           .)
        Stat
        [
          "break;"        (.gen.Branch(breakLabel);.)
        ]
                          (. gen.Label(l1); .)
      }

      "default:"
      Stat
    "}"                 (. gen.Label(breakLabel); .)

| "while"                (.
                            int l1, l2;
                            l1 = gen.NewLabel();
                            gen.Label(l1); l2=0;
                         .)
  Expr<out reg,
       out type>         (.
                            if (type == boolean) {
                               l2 = gen.NewLabel();
                               gen.BranchFalse(l2);
                            }
                            else SemErr("boolean type expected");
                         .)
   Stat                  (.
                            gen.Branch(l1);
                            gen.Label(l2);
                         .)

| "for"

  Stat                (.
                            int loop, escape;
                            loop = gen.NewLabel();
                            gen.Label(loop); escape=0;
                      .)
  Expr<out reg,
    out type>         (.
                            if (type == boolean) {
                               gen.BranchFalse(escape);
                            }
                            else SemErr("boolean type expected");
                      .)
  ";"
  Stat
  "do" "{"
    Stat
  "}"
                      (.
                            gen.Branch(loop);
                            gen.Label(escape);
                      .)

| "read"
  Ident<out name> ';'    (.
                            obj = tab.Find(name);
                            if (obj.type == integer) {
                               gen.ReadInteger();
                               if (obj.level == 0)
                                  gen.StoreGlobal(0, obj.adr, name);
                               else gen.StoreLocal(0, tab.curLevel-obj.level, obj.adr, name);
                            }
                            else SemErr("integer type expected");
                         .)

| "write"                (. string text; .)
  (
    Expr<out reg,
         out type>       (.
                            switch (type) {
                               case integer: gen.WriteInteger(reg, false);
                                             break;
                               case boolean: gen.WriteBoolean(false);
                                             break;
                            }
                         .)
  | String<out text>     (. gen.WriteString(text); .)
  )
  ';'

| "writeln"
  // note - for strings use write with \n in text
  Expr<out reg,
       out type>           (.
                              switch (type) {
                                 case integer: gen.WriteInteger(reg, true);
                                               break;
                                 case boolean: gen.WriteBoolean(true);
                                               break;
                              }
                           .)
  ';'

| '{'                      (. tab.OpenSubScope(); .)
  { ConstantDecl }
  { VarDecl }
  Stat { Stat }
  '}'                      (. tab.CloseSubScope(); .)
.

/*-------------------------------------------------------------------------------------------*/

Tastier                  (. string progName; .)
  = "program"
  Ident<out progName>    (. tab.OpenScope(); .)
  '{'
    { ConstantDecl }
    { VarDecl }          // global variables
    { ProcDecl<progName> }
                         (. tab.CloseScope(); .)
  '}'
.

/*-------------------------------------------------------------------------------------------*/

Term<out int reg,        // load value of Term into register
     out int type>       (. int typeR, regR; Op op; .)
  = Primary<out reg,
            out type>
  { MulOp<out op>
    Primary<out regR,
            out typeR>
                         (.
                            if (type == integer && typeR == integer)
                               gen.MulOp(op, reg, regR);
                            else SemErr("integer type expected");
                         .)
  }
.

/*-------------------------------------------------------------------------------------------*/

Type<out int type>
=                        (. type = undef; .)
 ( "int"                 (. type = integer; .)
 | "bool"                (. type = boolean; .)
 )
.

/*-------------------------------------------------------------------------------------------*/

VarDecl                 (. int type; string name; int subcategory = scalar; int maxIndex = -1; .)
= Type<out type>
  [
    "["                 (. subcategory = array; .)
        number          (.
                          maxIndex = Convert.ToInt32(t.val) - 1;
                        .)
    "]"
  ]
  Ident<out name>       (. tab.NewObj(name, var, type, subcategory, maxIndex, 0, 0); .)

  (. if( subcategory != array ) { .)
    [ ","
      Ident<out name>      (. tab.NewObj(name, var, type, undef, maxIndex, 0, 0); .)
    ]
  (. } .)
  ";"
.

/*-------------------------------------------------------------------------------------------*/

ConstantDecl             (. string name; int type; .)
= "const"
  Type<out type>
  Ident<out name>        (. tab.NewObj(name, constant, type, undef, -1, 0, 0); .)
  { ","
    Ident<out name>      (. tab.NewObj(name, constant, type, undef, -1, 0, 0); .)
  }";"
.

/*-------------------------------------------------------------------------------------------*/

ParamDecl<out int numParameters>  (. int type; string name; int subcategory = scalar; int maxIndex = -1; int paramAdr = -5; numParameters = 0; .)
= Type<out type>
  [
    "["                           (. subcategory = array; .)
        number                    (.
                                     maxIndex = Convert.ToInt32(t.val) - 1;
                                  .)
    "]"
  ]
  Ident<out name>                 (.
                                    tab.NewObj(name, var, type, subcategory, maxIndex, paramAdr, 0);
                                    paramAdr -= 1;
                                    numParameters += 1;
                                  .)
  { ","
    Type<out type>
    [
      "["                           (. subcategory = array; numParameters = 0; .)
          number                    (.
                                       maxIndex = Convert.ToInt32(t.val) - 1;
                                    .)
      "]"
    ]
    Ident<out name>                 (.
                                      tab.NewObj(name, var, type, subcategory, maxIndex, paramAdr, 0);
                                      paramAdr -= 1;
                                      numParameters += 1;
                                    .)
  }
.
END Tastier.
